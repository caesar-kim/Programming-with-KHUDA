# 6주차. 6장. 비지도 학습(p.285-p.338)
## 6-1. 군집 알고리즘(p.286)
- 과일 사진을 보내고 가장 많은 요청이 오는 과일을 판매 품목으로 선정하는 알고리즘.
- 또, 1위로 선정된 과일사진을 보낸 고객 몇 명 뽑아 이벤트 당첨자로 선정.
- 이 때 사진을 종류대로 모아야 한다.
### 타깃을 모르는 비지도 학습(p.287)
- 비지도학습 unsupervised learning
  - 타깃이 없을 때 사용하는 머신러닝 알고리즘
  - 사람이 가르쳐주지 않아도 무언가를 학습한다.
      - 사진 픽셀값을 평균내면 모이지 않을까?
      - 300장의 데이터를 준비하고 픽셀값으로 사진 분류.
### 과일 사진 데이터 준비하기(p.287)
- 사과, 바나나, 파인애플이 있는 흑백 사진
  - 넘파이 배열 기본 저장 포맷인 npy 형식으로 저장됨.
    - 코랩에서 ! 문자로 시작하면 이후 명령을 파이썬 코드가 아닌 리눅스 셀shell 명령으로 이해한다.
    - wget 명령은 원격 주소에서 데이터를 다운로드하여 저장한다.
    - -0 옵션에서 저장할 파일 이름을 지정할 수 있다.
```python
!wget https://bit.ly/fruits_300 -0 fruits_300.npy

import numpy as np
import matplotlib.pyplot as plt

fruits = np.load('fruits_300.npy')
print(fruits.shape)  # 배열 크기 확인
# 300, 100, 100  샘플 개수, 이미지 높이, 이미지 너비

# 첫 이미지의 첫 번째 행을 출력.
# 3차원 배열이기 때문에 처음 2개 인덱스를 0으로 지정, 마지막 인덱스는 지정하지 않거나 슬라이싱 연산자로 모두 선택 가능.
print(fruits[0, 0, :])

# 흑백 사진을 담고 있으므로 0~255까지의 정숫값을 가진다.
# matplotlib의 imshow() 함수로 넘파이 저장 이미지를 쉽게 그릴 수 있다.
# 흑백 이미지라 cmap를 gray로 지정.
plt.imshow(fruits[0], cmap='gray')
plt.show()
# 0에 가까울 수록 검고, 높은 값은 밝게 표시.
```
  - 보통 흑백 이미지는 바탕이 밝고 물체가 짙은 색이다. 그런데 여기서 나온 사진은 반대이다.
  - 이 흑백 이미지는 사진으로 찍은 이미지를 넘파이 배열로 변환할 때 반전시킨 것.
  - 흰바탕은 검게, 검은 것은 희게 만들었다.
    - 이렇게 바꾼 이유는?
    - 우리의 관심은 바탕면이 아닌 사과이기 때문.
    - 255에 가까운 곳에 집중하게 만들기 위해서.
    - 알고리즘이 어떠한 출력을 만들기 위해서 곱셈, 덧셈을 하는데 픽셀값이 애초에 0이면 출력도 0이라 의미가 없기 때문.
    - 픽셀값이 높으면 출력값도 커져서 의미를 부여하기 좋다.
```python
# 따라서 원래 이미지로 보기 위해서는
# cmap='gray_r'로 하여 반전하여 표현.
plt.imshow(fruits[0], cmap='gray_r')
plt.show()

fig, axs = plt.subplots(1, 2)
axs[0].imshow(fruits[100], cmap='gray_r')
axs[1].imshow(fruits[200], cmap='gray_r')
plt.show()
```
  - matplotlib의 subplots() 함수로 여러 개 그래프를 배열처럼 쌓을 수 있도록 도와준다.
    - 이 함수의 두 매개변수는 그래프를 쌓을 행과 열을 지정한다.
    - 여기서는 (1, 2)로 하나의 행과 2개의 열을 지정했다.
  - axs는 2개의 서브 그래프를 담고 있는 배열. axs[0]에 파인애플 이미지를, axs[1]에 바나나 이미지를 그렸다.
  - 이 장에선 subplots()를 사용해 한 번에 여러 개의 이미지를 그려본다.
  - 사과 100개, 파인애플 100개, 바나나 100개 이미지를  각각 사진 평균 내어서 차이를 확인해본다.

### 픽셀값 분석하기(p.292)
- fruits를 사과, 파인애플, 바나나로 나눈다.
  - 100X100인 이미지를 펼쳐서 10,000의 길이의 1차원 배열로 만든다.
  - 이렇게 펼치면 이미지 출력은 어렵지만, 배열 계산할 때 편리하다.
  - 우리는 3개의 과일이 100개씩 있는 걸 알고 있지만 실전에서는 몇 개가 입력될지 모른다는 점 참고하기.
    - 100개씩 선택하기 위해 슬라이싱 연산자 사용.
    - 그 다음 reshape() 메소드로 두 번째 차원(100)과 세 번째 차원(100)을 10,000으로 합친다.
    - 첫 번째 차원을 -1로 지정하면 자동으로 남은 차원을 할당한다.
    - 여기서는 첫 번째 차원이 샘플 개수이다.
```python
apple = fruits[0:100].reshape(-1, 100*100)
pineapple = fruits[100:200].reshape(-1, 100*100)
banana = fruits[200:300].reshape(-1, 100*100)

# 배열 크기 확인해보기
print(apple.shape)  # (100, 10000)

# 각 과일 종류별 배열에 들어있는 샘플의 픽셀 평균값을 계산해본다.
# mean() 메소드 사용. 각 샘플마다 픽셀 평균을 계산해야 하므로 평균 계산 축을 지정해야 한다.
# axis = 0 으로 하면 첫 번째 축인 행을 따라 계산한다. 행 방향으로 아래로
# axis = 1로 지정하면 두 번째 축인 열을 따라 계산한다. 열 방향으로 ->

# 샘플은 모두 가로로 나열했으니 axis=1로 지정하여 평균 계산.
# 평균 계산하는 np.mean() 함수도 되지만, 넘파이 배열은 이런 함수들을 메소드로 제공하기도 한다.
print(apple.mean(axis=1))  # 사과 100개에 대한 픽셀 평균값 계산
# 히스토그램을 그려서 평균값 분포를 한 눈에 확인 가능.
# 히스토그램을 모두 겹쳐 그려본다. 조금 투명하게 해야 겹치는 부분 잘 볼 수 있음.
# alpha 매개변수를 1보자 작게 하여 투명도 결정 가능.
# legend() 함수로 어떤 과일의 히스토그램인지 범례도 만들 수 있음.
plt.hist(np.mean(apple, axis=1), alpha=0.8)
plt.hist(np.mean(pineapple, axis=1), alpha=0.8)
plt.hist(np.mean(banana, axis=1), alpha=0.8)
plt.legend(['apple', 'pineapple', 'banana'])
plt.show()
```
- 히스토그램 결과
  - 결과를 보면 바나나 평균값은 40 아래에, 사과와 파인애플은 90~100 사이에 많이 겹쳐있다.
  - 바나나는 픽셀 평균만으로 쉽게 구분 가능. 바나나는 사진에서 차지하는 영역이 작기 때문에 평균값이 작다.
  - 사과, 파인애플은 픽셀 평균만으로 구분하기 힘들다.
- 샘플 전체 평균이 아닌 픽셀 별 평균값으로 비교하면 어떨까?
  - 세 과일은 모양이 다르므로 픽셀값이 높은 위치가 다를 것 같다.
  - 픽셀 평균 계산도 간단하다. axis = 0으로 지정.
  - matplotlib의 bar() 함수로 픽셀 10,000개에 대한 평균값을 막대그래프로 그려본다.
  - subplots() 함수로 3개의 서브 그래프를 만들어 사과, 파인애플, 바나나에 대한 막대그래프를 그려본다.
```python
fig, axs = plt.subplots(1, 3, figsize=(20, 5))
axs[0].bar(range(10000), np.mean(apple, axis=0))
axs[1].bar(range(10000), np.mean(pineapple, axis=0))
axs[2].bar(range(10000), np.mean(banana, axis=0))
plt.show()
```
- 각 과일 별 결과
  - 과일마다 값이 높은 구간이 다르다.
  - 사과는 아래쪽으로 갈수록 높고, 파인애플은 비교적 고르면서 높다. 바나나는 중앙 픽셀값이 높다.
  - 픽셀 평균을 100X100 크기로 바꿔서 이미지처럼 출력하여 위 그래프와 비교하면 더 좋다.
  - 픽셀을 평균 낸 이미지를 모든 사진을 합쳐놓은 대표 이미지로 생각할 수 있다.
```python
apple_mean = np.mean(apple, axis=0).reshape(100, 100)
pineapple_mean = np.mean(pineapple, axis=0).reshape(100, 100)
banana_mean = np.mean(banana, axis=0).reshape(100, 100)
fig, axs = plt.subplots(1, 3, figsize(20, 5))
axs[0].imshow(apple_mean, cmap='gray_r')
axs[1].imshow(pineapple_mean, cmap='gray_r')
axs[2].imshow(banana_mean, cmap='gray_r')
plt.show()
```
- 세 과일은 픽셀 위치에 따라 값의 크기가 차이 난다. 따라서 이렇게 만든 대표이미지와 가까운 사진을 고르면 되지 않나?
### 평균값과 가까운 사진 고르기(p.297)

## 6-2. k-평균(p.303)
### k-평균 알고리즘 소개(p.304)
### KMeans 클래스(p.305)
### 클러스터 중심(p.309)
### 최적의 k 찾기(p.311)

## 6-3. 주성분 분석(p.318)
### 차원과 차원 축소(p.319)
### 주성분 분석 소개(p.320)
### PCA 클래스(p.322)
### 원본 데이터 재구성(p.324)
### 설명된 분산(p.325)
### 다른 알고리즘과 함께 사용하기(p.327)
